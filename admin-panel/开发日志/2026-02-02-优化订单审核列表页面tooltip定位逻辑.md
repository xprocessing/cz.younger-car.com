# 2026-02-02 优化订单审核列表页面tooltip定位逻辑

## 需求描述

在订单审核列表页面中，tooltip的定位需要根据每个 `truncate-text` 元素的实际位置来动态计算，确保tooltip始终显示在视口内，不会被滚动或视口边界遮挡。

## 问题分析

### 原始实现问题

原始代码使用简单的固定偏移量定位tooltip：

```javascript
const rect = this.getBoundingClientRect();
tooltip.style.left = rect.left + 'px';
tooltip.style.top = (rect.bottom + 5) + 'px';
```

**存在的问题：**
1. **未考虑滚动偏移**：页面滚动后，tooltip位置会偏移
2. **未考虑视口边界**：tooltip可能超出视口右边界或底部边界
3. **固定定位**：所有tooltip都使用相同的偏移量，不考虑元素实际位置

## 优化方案

### 1. 获取滚动偏移量

```javascript
const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
```

**说明：**
- `window.pageXOffset/pageYOffset`：现代浏览器支持的滚动偏移量
- `document.documentElement.scrollLeft/scrollTop`：兼容旧版浏览器的滚动偏移量
- 两者结合使用，确保兼容性

### 2. 获取视口尺寸

```javascript
const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
```

**说明：**
- `window.innerWidth/innerHeight`：现代浏览器支持的视口尺寸
- `document.documentElement.clientWidth/clientHeight`：兼容旧版浏览器的视口尺寸
- 用于检测tooltip是否会超出视口边界

### 3. 计算初始位置

```javascript
let tooltipLeft = rect.left + scrollLeft;
let tooltipTop = rect.bottom + scrollTop + 5;
```

**说明：**
- `rect.left + scrollLeft`：元素相对于文档的左侧位置
- `rect.bottom + scrollTop + 5`：元素底部相对于文档的位置，向下偏移5px

### 4. 获取tooltip尺寸

```javascript
const tooltipRect = tooltip.getBoundingClientRect();
```

**说明：**
- 在定位之前先获取tooltip的实际尺寸
- 用于边界检测和位置调整

### 5. 检测右边界

```javascript
if (tooltipLeft + tooltipRect.width > viewportWidth) {
    tooltipLeft = rect.right + scrollLeft - tooltipRect.width;
}
```

**说明：**
- 检测tooltip是否会超出视口右边界
- 如果超出，将tooltip定位到元素右侧
- 使用 `rect.right` 确保tooltip紧贴元素右边缘

### 6. 检测底部边界

```javascript
if (tooltipTop + tooltipRect.height > viewportHeight + scrollTop) {
    tooltipTop = rect.top + scrollTop - tooltipRect.height - 5;
}
```

**说明：**
- 检测tooltip是否会超出视口底部边界
- 如果超出，将tooltip定位到元素上方
- 使用 `rect.top` 确保tooltip紧贴元素上边缘

### 7. 应用最终位置

```javascript
tooltip.style.left = tooltipLeft + 'px';
tooltip.style.top = tooltipTop + 'px';
```

## 完整代码

```javascript
document.addEventListener('DOMContentLoaded', function() {
    const truncateTexts = document.querySelectorAll('.truncate-text');
    
    truncateTexts.forEach(function(element) {
        element.addEventListener('mouseenter', function(e) {
            const fullText = this.getAttribute('data-full');
            if (!fullText || fullText === '') return;
            
            let tooltip = document.createElement('div');
            tooltip.className = 'tooltip-custom';
            
            try {
                const jsonData = JSON.parse(fullText);
                if (Array.isArray(jsonData)) {
                    let html = '<strong>运费列表：</strong><br>';
                    jsonData.forEach(function(item, index) {
                        html += `<br><strong>${index + 1}.</strong> `;
                        if (item.channel_code) {
                            html += `渠道: ${item.channel_code} | `;
                        }
                        if (item.currency && item.totalFee) {
                            html += `费用: ${item.currency} ${item.totalFee}`;
                        } else if (item.totalFee) {
                            html += `费用: ${item.totalFee}`;
                        }
                        if (item.currency === null || item.totalFee === null) {
                            html += ' (无报价)';
                        }
                    });
                    tooltip.innerHTML = html;
                } else {
                    tooltip.textContent = fullText;
                }
            } catch (e) {
                tooltip.textContent = fullText;
            }
            
            document.body.appendChild(tooltip);
            
            const rect = this.getBoundingClientRect();
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            
            let tooltipLeft = rect.left + scrollLeft;
            let tooltipTop = rect.bottom + scrollTop + 5;
            
            const tooltipRect = tooltip.getBoundingClientRect();
            
            if (tooltipLeft + tooltipRect.width > viewportWidth) {
                tooltipLeft = rect.right + scrollLeft - tooltipRect.width;
            }
            
            if (tooltipTop + tooltipRect.height > viewportHeight + scrollTop) {
                tooltipTop = rect.top + scrollTop - tooltipRect.height - 5;
            }
            
            tooltip.style.left = tooltipLeft + 'px';
            tooltip.style.top = tooltipTop + 'px';
            
            this._tooltip = tooltip;
        });
        
        element.addEventListener('mouseleave', function() {
            if (this._tooltip) {
                document.body.removeChild(this._tooltip);
                this._tooltip = null;
            }
        });
    });
});
```

## 优化效果

### 场景1：元素在视口中间
- tooltip显示在元素下方
- 位置正常，无遮挡

### 场景2：元素靠近视口右边界
- tooltip自动调整到元素右侧
- 避免超出视口右边界

### 场景3：元素靠近视口底部边界
- tooltip自动调整到元素上方
- 避免超出视口底部边界

### 场景4：页面滚动后
- tooltip位置随滚动自动调整
- 始终显示在正确位置

## 技术特点

1. **动态定位**：根据每个元素的实际位置计算tooltip位置
2. **滚动感知**：考虑页面滚动偏移量，确保位置准确
3. **边界检测**：检测tooltip是否会超出视口边界
4. **智能调整**：自动调整tooltip位置以避免超出边界
5. **兼容性好**：支持现代浏览器和旧版浏览器

## 修改内容

### index.php 视图（第304-327行）

**修改前：**
```javascript
const rect = this.getBoundingClientRect();
tooltip.style.left = rect.left + 'px';
tooltip.style.top = (rect.bottom + 5) + 'px';
```

**修改后：**
```javascript
const rect = this.getBoundingClientRect();
const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
const viewportHeight = window.innerHeight || document.documentElement.clientHeight;

let tooltipLeft = rect.left + scrollLeft;
let tooltipTop = rect.bottom + scrollTop + 5;

const tooltipRect = tooltip.getBoundingClientRect();

if (tooltipLeft + tooltipRect.width > viewportWidth) {
    tooltipLeft = rect.right + scrollLeft - tooltipRect.width;
}

if (tooltipTop + tooltipRect.height > viewportHeight + scrollTop) {
    tooltipTop = rect.top + scrollTop - tooltipRect.height - 5;
}

tooltip.style.left = tooltipLeft + 'px';
tooltip.style.top = tooltipTop + 'px';
```

## 用户体验提升

1. **位置准确**：tooltip始终显示在正确位置，不受滚动影响
2. **边界安全**：tooltip不会超出视口边界，始终可见
3. **智能调整**：根据元素位置自动调整tooltip显示方向
4. **滚动友好**：页面滚动后tooltip位置自动更新
5. **多场景适配**：支持各种位置和滚动状态的显示需求

## 影响文件

- `admin-panel/views/order_review/index.php`

## 测试建议

测试以下场景：
1. 元素在视口中间位置
2. 元素靠近视口右边界
3. 元素靠近视口底部边界
4. 元素在视口右下角
5. 页面滚动后的tooltip位置
6. 不同屏幕尺寸下的tooltip显示
7. 快速移动鼠标时的tooltip响应
8. 多个tooltip同时显示的情况
