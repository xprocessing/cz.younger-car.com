# 2026-02-02 订单审核列表页面tooltip鼠标悬浮优化

## 需求描述

在订单审核列表页面中，tooltip弹窗在鼠标离开元素后会延迟消失，但如果鼠标移动到tooltip上查看详细内容时，tooltip仍然会消失。需要优化tooltip的鼠标悬浮逻辑，让鼠标悬浮在tooltip上时tooltip不消失，提升用户体验。

## 问题分析

### 当前实现问题

当前代码虽然添加了延迟消失功能，但存在以下问题：

```javascript
element.addEventListener('mouseleave', function() {
    hideTimeout = setTimeout(function() {
        if (tooltip && tooltip.parentNode) {
            document.body.removeChild(tooltip);
            tooltip = null;
        }
    }, 300);
});
```

**存在的问题：**
1. **tooltip不可交互**：鼠标移动到tooltip上时，tooltip仍然会消失
2. **阅读困难**：用户无法在tooltip上滚动查看完整内容
3. **操作不便**：用户需要精确控制鼠标位置才能保持tooltip显示

## 优化方案

### 1. 为tooltip添加鼠标进入事件

当鼠标进入tooltip时，清除延迟移除的定时器：

```javascript
tooltip.addEventListener('mouseenter', function() {
    clearTimeout(hideTimeout);
});
```

**关键点：**
- 鼠标进入tooltip时清除定时器
- 保持tooltip的显示状态
- 允许用户在tooltip上操作

### 2. 为tooltip添加鼠标离开事件

当鼠标离开tooltip时，重新设置延迟移除：

```javascript
tooltip.addEventListener('mouseleave', function() {
    hideTimeout = setTimeout(function() {
        if (tooltip && tooltip.parentNode) {
            document.body.removeChild(tooltip);
            tooltip = null;
        }
    }, 300);
});
```

**关键点：**
- 鼠标离开tooltip时重新设置定时器
- 延迟300ms后移除tooltip
- 给用户缓冲时间

## 完整代码

```javascript
document.addEventListener('DOMContentLoaded', function() {
    const truncateTexts = document.querySelectorAll('.truncate-text');
    
    truncateTexts.forEach(function(element) {
        let tooltip = null;
        let hideTimeout = null;
        
        element.addEventListener('mouseenter', function(e) {
            clearTimeout(hideTimeout);
            
            const fullText = this.getAttribute('data-full');
            if (!fullText || fullText === '') return;
            
            tooltip = document.createElement('div');
            tooltip.className = 'tooltip-custom';
            
            try {
                const jsonData = JSON.parse(fullText);
                if (Array.isArray(jsonData)) {
                    let html = '<strong>运费列表：</strong><br>';
                    jsonData.forEach(function(item, index) {
                        html += `<br><strong>${index + 1}.</strong> `;
                        if (item.channel_code) {
                            html += `渠道: ${item.channel_code} | `;
                        }
                        if (item.currency && item.totalFee) {
                            html += `费用: ${item.currency} ${item.totalFee}`;
                        } else if (item.totalFee) {
                            html += `费用: ${item.totalFee}`;
                        }
                        if (item.currency === null || item.totalFee === null) {
                            html += ' (无报价)';
                        }
                    });
                    tooltip.innerHTML = html;
                } else {
                    tooltip.textContent = fullText;
                }
            } catch (e) {
                tooltip.textContent = fullText;
            }
            
            document.body.appendChild(tooltip);
            
            const rect = this.getBoundingClientRect();
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            
            let tooltipLeft = rect.left + scrollLeft;
            let tooltipTop = rect.bottom + scrollTop + 5;
            
            const tooltipRect = tooltip.getBoundingClientRect();
            
            if (tooltipLeft + tooltipRect.width > viewportWidth) {
                tooltipLeft = rect.right + scrollLeft - tooltipRect.width;
            }
            
            if (tooltipTop + tooltipRect.height > viewportHeight + scrollTop) {
                tooltipTop = rect.top + scrollTop - tooltipRect.height - 5;
            }
            
            tooltip.style.left = tooltipLeft + 'px';
            tooltip.style.top = tooltipTop + 'px';
            
            this._tooltip = tooltip;
            
            tooltip.addEventListener('mouseenter', function() {
                clearTimeout(hideTimeout);
            });
            
            tooltip.addEventListener('mouseleave', function() {
                hideTimeout = setTimeout(function() {
                    if (tooltip && tooltip.parentNode) {
                        document.body.removeChild(tooltip);
                        tooltip = null;
                    }
                }, 300);
            });
        });
        
        element.addEventListener('mouseleave', function() {
            hideTimeout = setTimeout(function() {
                if (tooltip && tooltip.parentNode) {
                    document.body.removeChild(tooltip);
                    tooltip = null;
                }
            }, 300);
        });
        
        element.addEventListener('mouseenter', function() {
            clearTimeout(hideTimeout);
        });
    });
});
```

## 优化效果

### 场景1：鼠标从元素移动到tooltip
- tooltip不会消失
- 用户可以在tooltip上查看详细内容
- 提升阅读体验

### 场景2：鼠标在tooltip上滚动
- tooltip保持显示
- 用户可以滚动查看完整内容
- 不会因为滚动而消失

### 场景3：鼠标离开tooltip
- 延迟300ms后消失
- 给用户缓冲时间
- 避免误操作

### 场景4：鼠标在元素和tooltip之间移动
- tooltip保持显示
- 不会因为短暂离开而消失
- 提供流畅的用户体验

## 技术特点

1. **双向事件监听**：同时监听元素和tooltip的鼠标事件
2. **定时器管理**：使用 `clearTimeout` 清除定时器
3. **状态保持**：鼠标在tooltip上时保持显示状态
4. **延迟消失**：使用 `setTimeout` 延迟300ms移除tooltip
5. **交互友好**：允许用户在tooltip上操作

## 用户体验提升

1. **可交互性**：鼠标可以在tooltip上移动和滚动
2. **阅读时间**：用户有足够时间查看完整的运费列表
3. **操作便利**：不需要精确控制鼠标位置
4. **视觉稳定**：tooltip不会频繁闪烁
5. **容错性**：鼠标意外离开后还有缓冲时间

## 修改内容

### index.php 视图（第344-357行）

**修改前：**
```javascript
tooltip.style.left = tooltipLeft + 'px';
tooltip.style.top = tooltipTop + 'px';

this._tooltip = tooltip;
```

**修改后：**
```javascript
tooltip.style.left = tooltipLeft + 'px';
tooltip.style.top = tooltipTop + 'px';

this._tooltip = tooltip;

tooltip.addEventListener('mouseenter', function() {
    clearTimeout(hideTimeout);
});

tooltip.addEventListener('mouseleave', function() {
    hideTimeout = setTimeout(function() {
        if (tooltip && tooltip.parentNode) {
            document.body.removeChild(tooltip);
            tooltip = null;
        }
    }, 300);
});
```

## 影响文件

- `admin-panel/views/order_review/index.php`

## 测试建议

测试以下场景：
1. 鼠标从元素移动到tooltip，tooltip是否保持显示
2. 鼠标在tooltip上滚动，tooltip是否保持显示
3. 鼠标离开tooltip，tooltip是否延迟消失
4. 鼠标在元素和tooltip之间移动，tooltip是否保持显示
5. 查看完整的运费列表，是否有足够时间
6. 多个tooltip同时显示的情况
