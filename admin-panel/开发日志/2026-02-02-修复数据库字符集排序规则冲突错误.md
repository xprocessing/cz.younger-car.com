# 2026-02-02 修复数据库字符集排序规则冲突错误

## 问题描述

在订单审核列表页面访问时出现以下错误：

```
Fatal error: Uncaught PDOException: SQLSTATE[HY000]: General error: 1267 Illegal mix of collations (utf8mb4_unicode_ci,IMPLICIT) and (utf8mb4_general_ci,IMPLICIT) for operation '=' in /www/wwwroot/cz.younger-car.com/admin-panel/includes/database.php:37
```

## 错误原因

在 `order_review` 表和 `store` 表进行 JOIN 查询时，两个表的字符集排序规则（collation）不一致：
- `order_review` 表使用 `utf8mb4_unicode_ci`
- `store` 表使用 `utf8mb4_general_ci`

当使用 `orr.store_id = s.store_id` 进行关联查询时，MySQL 无法直接比较不同排序规则的字符串，导致错误。

## 解决方案

在 JOIN 条件中明确指定字符集排序规则，使用 `COLLATE` 子句统一排序规则：

```sql
LEFT JOIN store s ON orr.store_id = s.store_id COLLATE utf8mb4_unicode_ci
```

## 修改内容

### OrderReview.php 模型

#### 修改 `getAll()` 方法（第30行）
```php
public function getAll($limit = null, $offset = 0) {
    $sql = "SELECT orr.*, s.platform_name, s.store_name 
            FROM order_review orr 
            LEFT JOIN store s ON orr.store_id = s.store_id COLLATE utf8mb4_unicode_ci 
            ORDER BY orr.id DESC";
    // ...
}
```

#### 修改 `searchWithFilters()` 方法（第109行）
```php
public function searchWithFilters($keyword, $reviewStatus, $startDate, $endDate, $limit, $offset) {
    $sql = "SELECT orr.*, s.platform_name, s.store_name 
            FROM order_review orr 
            LEFT JOIN store s ON orr.store_id = s.store_id COLLATE utf8mb4_unicode_ci 
            WHERE 1=1";
    // ...
}
```

## 技术说明

### COLLATE 子句
`COLLATE` 子句用于指定字符串比较时使用的排序规则：

```sql
column_name COLLATE collation_name
```

在本例中：
- `orr.store_id` 使用 `order_review` 表的默认排序规则 `utf8mb4_unicode_ci`
- `s.store_id COLLATE utf8mb4_unicode_ci` 强制使用 `utf8mb4_unicode_ci` 排序规则
- 这样两个字段使用相同的排序规则，可以进行比较

### 字符集排序规则类型

MySQL 常见的 utf8mb4 排序规则：
- `utf8mb4_unicode_ci`：基于 Unicode 排序，支持多语言，推荐使用
- `utf8mb4_general_ci`：基于通用规则排序，性能稍好，但对某些语言支持不完善
- `utf8mb4_bin`：二进制排序，区分大小写

选择 `utf8mb4_unicode_ci` 的原因：
1. 更好的多语言支持
2. 与 `order_review` 表的排序规则一致
3. 推荐用于国际化应用

## 其他解决方案

### 方案1：统一数据库表排序规则（推荐）
修改 `store` 表的字符集排序规则：

```sql
ALTER TABLE store CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

**优点：**
- 从根本上解决问题
- 所有查询都不需要 COLLATE 子句
- 数据库结构更统一

**缺点：**
- 需要修改数据库表结构
- 可能影响其他使用该表的代码

### 方案2：在数据库连接时指定排序规则
在数据库配置中设置默认排序规则：

```php
$dsn = "mysql:host=$host;dbname=$dbname;charset=utf8mb4";
$options = [
    PDO::MYSQL_ATTR_INIT_COMMAND => "SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci"
];
```

**优点：**
- 全局生效
- 不需要修改每个查询

**缺点：**
- 可能影响其他表和查询
- 需要测试所有功能

### 方案3：使用 COLLATE 子句（当前方案）
在每个 JOIN 查询中指定排序规则：

```sql
LEFT JOIN store s ON orr.store_id = s.store_id COLLATE utf8mb4_unicode_ci
```

**优点：**
- 不需要修改数据库结构
- 只影响特定查询
- 实施简单，风险低

**缺点：**
- 需要在每个相关查询中添加 COLLATE
- 代码冗余

## 影响文件

- `admin-panel/models/OrderReview.php`

## 测试验证

修复后应测试以下功能：
1. 订单审核列表页面正常显示
2. 店铺信息正确显示（平台名称 - 店铺名称）
3. 搜索功能正常工作
4. 分页功能正常工作
5. 筛选功能正常工作

## 经验教训

1. **字符集一致性**：在设计数据库时，应确保所有表使用相同的字符集和排序规则
2. **JOIN 查询注意**：在进行跨表 JOIN 时，注意字符集排序规则的一致性
3. **错误处理**：遇到 PDOException 时，仔细检查 SQL 语句的字符集和排序规则
4. **COLLATE 使用**：了解 COLLATE 子句的用法，可以在查询中临时解决排序规则冲突

## 建议

建议在后续维护中，统一所有表的字符集排序规则为 `utf8mb4_unicode_ci`，从根本上避免此类问题。

可以执行以下 SQL 语句统一所有表的排序规则：

```sql
-- 查看 all 表的字符集和排序规则
SELECT 
    TABLE_NAME, 
    TABLE_COLLATION 
FROM 
    information_schema.TABLES 
WHERE 
    TABLE_SCHEMA = 'your_database_name';

-- 统一所有表的排序规则为 utf8mb4_unicode_ci
ALTER TABLE store CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
-- 对其他表也执行相同的操作
```
