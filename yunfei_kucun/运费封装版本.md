好的，按照 「配置分离、逻辑封装、自动加载」的思路，我们来对代码进行结构化封装，让它更易于维护、扩展和测试。

### 最终项目结构
```
.
├── composer.json
├── config.php
├── public
│   └── index.php
└── src
    ├── Contracts
    │   └── ShippingCalculatorInterface.php
    ├── Exceptions
    │   └── CalculatorException.php
    ├── Http
    │   └── Controllers
    │       └── ShippingController.php
    └── Services
        ├── EmsService.php
        └── WedoService.php
```

---

### 步骤 1：使用 Composer 进行自动加载和依赖管理
首先，在项目根目录创建 `composer.json` 文件。这是现代 PHP 项目的标准配置。

**`composer.json`**
```json
{
    "name": "your-company/shipping-calculator",
    "description": "A PHP library to calculate shipping fees from multiple carriers.",
    "type": "project",
    "autoload": {
        "psr-4": {
            "ShippingCalculator\\": "src/"
        }
    },
    "require": {
        "php": ">=7.4",
        "ext-curl": "*",
        "ext-json": "*",
        "ext-simplexml": "*"
    }
}
```

**执行命令**：在项目根目录下运行 `composer install`。这会创建 `vendor` 目录并生成自动加载器。

---

### 步骤 2：创建统一的配置文件
将所有硬编码的配置（如 API 密钥、URL、渠道列表）提取到一个单独的配置文件中。

**`config.php`**
```php
<?php
return [
    'ems' => [
        'token' => getenv('EMS_TOKEN'), // 建议使用环境变量
        'key' => getenv('EMS_KEY'),
        'url' => 'http://cpws.ems.com.cn/default/svc/web-service',
        'warehouses' => ['USWE', 'USEA'],
        'channels' => [
            'FEDEX-GROUND-EA', 'SS-FEDEX-G-E', 'FEDEX-SM', 'FEDEX-LP',
            'AMAZON-GROUND', 'USPS-FIRST-CLASS', 'USPS-PRIORITY', 'DHL-US-SP',
            'DHL-US-BP', 'YUN-GROUND', 'CE-PARCEL', 'CE-GROUND-EA',
            'UPS-GROUND-EA', 'UPS-GROUND-MULT', 'UPS-SUREPOST', 'UPS-2ND-DAY'
        ],
        'max_batch_size' => 12,
    ],
    'wedo' => [
        'app_id' => getenv('WD_APP_ID'),
        'app_token' => getenv('WD_APP_TOKEN'),
        'url' => 'http://fg.wedoexpress.com/api.php?mod=apiManage&act=getShipFeeQuery',
        'channels' => [
            'AMGD', 'FEDHDE', 'FEDHDEMP', 'UPSGDE', 'NJUSPSGA', 'USPSPME', 'SPEEDXNJ',
            'FDXSPE', 'UNIUNINJ', 'GOFONJ', 'GFYUNNJ', 'AMGDCA', 'UPSGW', 'CAUSPSGA',
            'USPSPMW', 'USPSGACASG', 'FEDHDW', 'FEDHDWMP', 'UPSGWFBA', 'SPEEDXCA',
            'CAGLS', 'FEDSPW', 'UNIUNICA', 'GOFOCA', 'GFYUNCA', 'FEDIGCA'
        ],
        'max_batch_size' => 5,
    ],
    'display' => [
        'exchange_rate_usd_cny' => 7.0,
    ]
];
```

> **最佳实践**：不要直接在 `config.php` 中写入敏感信息（如 `EMS_TOKEN`）。使用环境变量（通过 `getenv()` 或像 `vlucas/phpdotenv` 这样的库）来管理它们。

---

### 步骤 3：定义核心接口和异常
为了规范不同物流服务的行为，我们定义一个接口。同时，创建一个自定义异常来处理计算过程中的错误。

**`src/Contracts/ShippingCalculatorInterface.php`**
```php
<?php

namespace ShippingCalculator\Contracts;

interface ShippingCalculatorInterface
{
    /**
     * Calculate shipping fees based on package and destination information.
     *
     * @param array $params An array containing 'weight', 'length', 'width', 'height', 'postcode', 'city'.
     * @return array An array of results sorted by price.
     */
    public function calculate(array $params): array;
}
```

**`src/Exceptions/CalculatorException.php`**
```php
<?php

namespace ShippingCalculator\Exceptions;

use Exception;

class CalculatorException extends Exception
{
    // 可以自定义一些异常代码或方法
}
```

---

### 步骤 4：封装服务类
将 EMS 和运德的逻辑分别封装到各自的服务类中，并实现上面定义的接口。

**`src/Services/EmsService.php`**
```php
<?php

namespace ShippingCalculator\Services;

use ShippingCalculator\Contracts\ShippingCalculatorInterface;
use ShippingCalculator\Exceptions\CalculatorException;

class EmsService implements ShippingCalculatorInterface
{
    private $config;

    public function __construct(array $config)
    {
        $this->config = $config;
    }

    public function calculate(array $params): array
    {
        // 输入验证
        $this->validateParams($params);

        $baseParams = $this->buildBaseParams($params);
        $requests = $this->buildRequests($baseParams);
        
        // 分批并发请求
        $results = $this->sendConcurrentRequests($requests);
        
        // 处理和排序结果
        return $this->processAndSortResults($results);
    }

    private function validateParams(array $params): void
    {
        // ... 实现参数验证逻辑 ...
        if (empty($params['postcode'])) {
             throw new CalculatorException("EMS: Postcode is required.");
        }
    }

    private function buildBaseParams(array $params): array
    {
        return [
            "country_code" => "US",
            "postcode"     => $params['postcode'],
            "type"         => 1,
            "weight"       => round($params['weight'], 3),
            "length"       => max(1, round($params['length'], 1)),
            "width"        => max(1, round($params['width'], 1)),
            "height"       => max(1, round($params['height'], 1)),
            "pieces"       => 1
        ];
    }
    
    private function buildRequests(array $baseParams): array
    {
        $requests = [];
        foreach ($this->config['warehouses'] as $warehouse) {
            foreach ($this->config['channels'] as $channel) {
                $key = "$warehouse||$channel";
                $requests[$key] = array_merge($baseParams, [
                    "warehouse_code" => $warehouse,
                    "shipping_method" => strtoupper($channel),
                ]);
            }
        }
        return $requests;
    }

    private function sendConcurrentRequests(array $requests): array
    {
        // ... 实现 cURL 并发请求的核心逻辑 ...
        // 这部分代码来自你原来的 concurrentEmsRequests 函数
        // 但要改造为类的私有方法
        $mh = curl_multi_init();
        $handles = [];
        
        foreach ($requests as $key => $params) {
             // ... 创建 cURL handle ...
             $ch = curl_init();
             // ... 设置 curl_setopt ...
             curl_multi_add_handle($mh, $ch);
             $handles[$key] = $ch;
        }

        // ... 执行并获取结果 ...
        
        return $results;
    }

    private function processAndSortResults(array $rawResults): array
    {
        // ... 实现结果清洗、格式化和排序逻辑 ...
        $sortedData = [];
        foreach ($rawResults as $key => $data) {
            // ...
        }
        
        usort($sortedData, fn($a, $b) => $a['total_fee'] <=> $b['total_fee']);
        
        return $sortedData;
    }
}
```

**`src/Services/WedoService.php`**
```php
<?php

namespace ShippingCalculator\Services;

use ShippingCalculator\Contracts\ShippingCalculatorInterface;
use ShippingCalculator\Exceptions\CalculatorException;

class WedoService implements ShippingCalculatorInterface
{
    private $config;

    public function __construct(array $config)
    {
        $this->config = $config;
    }

    public function calculate(array $params): array
    {
        // 类似 EmsService 的结构
        $this->validateParams($params);
        $baseParams = $this->buildBaseParams($params);
        $channelGroups = array_chunk($this->config['channels'], $this->config['max_batch_size']);
        
        $results = $this->sendConcurrentRequests($channelGroups, $baseParams);
        
        return $this->processAndSortResults($results);
    }

    // ... 实现 validateParams, buildBaseParams, sendConcurrentRequests, processAndSortResults 等私有方法 ...
    // 代码来自你原来的运德物流部分
}
```

---

### 步骤 5：创建控制器
控制器作为应用的入口点，负责接收 HTTP 请求，调用相应的服务，并返回响应。

**`src/Http/Controllers/ShippingController.php`**
```php
<?php

namespace ShippingCalculator\Http\Controllers;

use ShippingCalculator\Services\EmsService;
use ShippingCalculator\Services\WedoService;
use ShippingCalculator\Exceptions\CalculatorException;

class ShippingController
{
    private $emsService;
    private $wedoService;
    private $displayConfig;

    public function __construct(EmsService $emsService, WedoService $wedoService, array $displayConfig)
    {
        $this->emsService = $emsService;
        $this->wedoService = $wedoService;
        $this->displayConfig = $displayConfig;
    }

    public function showCalculator()
    {
        // 从 $_GET 中获取参数
        $params = $this->getParamsFromRequest();

        try {
            // 调用服务进行计算
            $emsResults = $this->emsService->calculate($params);
            $wedoResults = $this->wedoService->calculate($params);
        } catch (CalculatorException $e) {
            // 处理异常
            echo "Error: " . $e->getMessage();
            return;
        }

        // 渲染视图（这里简化为直接输出）
        $this->renderResults($params, $emsResults, $wedoResults);
    }

    private function getParamsFromRequest(): array
    {
        return [
            'global_order_no' => trim($_GET['global_order_no'] ?? ''),
            'city' => trim($_GET['city'] ?? ''),
            'postcode' => trim($_GET['postcode'] ?? ''),
            'weight' => max(0.001, floatval($_GET['weight'] ?? 0)),
            'length' => floatval($_GET['length'] ?? 0),
            'width' => floatval($_GET['width'] ?? 0),
            'height' => floatval($_GET['height'] ?? 0),
        ];
    }

    private function renderResults(array $params, array $emsResults, array $wedoResults)
    {
        // ... 这里是你原来的 HTML 输出和表格渲染逻辑 ...
        // 可以将其分离到一个视图文件中，例如使用 Twig 或 Blade 模板引擎
        echo '<h1>🌐 订单号: ' . htmlspecialchars($params['global_order_no'] ?: 'N/A') . '</h1>';
        
        // 输出 EMS 结果表格
        // ...
        
        // 输出运德结果表格
        // ...
    }
}
```

---

### 步骤 6：创建入口文件
最后，在 `public` 目录下创建 `index.php`，这是 Web 服务器直接访问的唯一文件。

**`public/index.php`**
```php
<?php

// 引入 Composer 自动加载器
require_once __DIR__ . '/../vendor/autoload.php';

// 加载配置
$config = require_once __DIR__ . '/../config.php';

// 设置 CORS 头
header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Methods: GET, OPTIONS");
header("Access-Control-Allow-Headers: Content-Type");
header("Content-Type: text/html; charset=utf-8");

// 依赖注入：创建服务和控制器实例
$emsService = new \ShippingCalculator\Services\EmsService($config['ems']);
$wedoService = new \ShippingCalculator\Services\WedoService($config['wedo']);

$controller = new \ShippingCalculator\Http\Controllers\ShippingController(
    $emsService,
    $wedoService,
    $config['display']
);

// 处理请求
$controller->showCalculator();
```

### 总结与优势

1.  **关注点分离 (Separation of Concerns)**：
    *   **配置** 在 `config.php`。
    *   **业务逻辑** 在 `src/Services/`。
    *   **HTTP 处理** 在 `src/Http/Controllers/`。
    *   **接口定义** 在 `src/Contracts/`。
    每个部分只负责自己的事情，代码更清晰。

2.  **可维护性 (Maintainability)**：
    *   想修改 EMS 的 API 地址？只需改 `config.php`。
    *   想优化运德的并发逻辑？只需看 `src/Services/WedoService.php`。
    *   想更换前端模板？只需修改 `renderResults` 方法或引入模板引擎。

3.  **可扩展性 (Extensibility)**：
    *   想增加一个新的物流商，比如 "DHL"？只需创建一个 `DhlService` 类并实现 `ShippingCalculatorInterface` 接口，然后在控制器中注入它即可。无需改动现有代码。

4.  **可测试性 (Testability)**：
    *   服务类 `EmsService` 和 `WedoService` 不依赖于全局变量（如 `$_GET`），它们的输入是明确的数组参数。这使得编写单元测试变得非常容易。你可以用模拟数据调用 `calculate()` 方法并断言结果是否正确。

5.  **专业规范 (Professionalism)**：
    *   遵循 PSR-4 自动加载标准。
    *   使用命名空间避免类名冲突。
    *   通过构造函数注入依赖（Dependency Injection），使代码松耦合。

这个封装后的结构将一个简单的脚本提升为了一个小型但专业的 PHP 应用。